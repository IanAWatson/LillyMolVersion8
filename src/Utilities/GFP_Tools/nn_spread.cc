// Spread implementation using precomputed distances.
// Nearnest neighbour data is read from serialized NearNeighbours protos

#include <chrono>
#include <iostream>
#include <limits>
#include <optional>

#define USE_OMP
#ifdef USE_OMP
#include <omp.h>
#endif

#define RESIZABLE_ARRAY_IWQSORT_IMPLEMENTATION
#include "Foundational/accumulator/accumulator.h"
#include "Foundational/cmdline/cmdline.h"
#include "Foundational/data_source/iwstring_data_source.h"
#include "Foundational/data_source/tfdatarecord.h"
#include "Foundational/iwmisc/misc.h"
#include "Foundational/iwmisc/report_progress.h"
#include "Foundational/iwstring/iw_stl_hash_map.h"

#include "spread_weights.h"

#ifdef BUILD_BAZEL
#include "Utilities/GFP_Tools/nearneighbours.pb.h"
#else
#include "nearneighbours.pb.h"
#endif

namespace nn_spread {

IWString smiles_tag = "$SMI<";
IWString identifier_tag = "PCN<";
IWString distance_tag = "DIST<";

using std::cerr;

using iw_tf_data_record::TFDataReader;

void
Usage(int rc) {
  // clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
  cerr << R"(Performs spread selection on a file, or files, of serialized NearNeighbours protos.
This tool is designed for the case of large sets of fingerprints, mostly greater than say 1M.
For smaller sets, just run gfp_spread_standard, or gfp_spread_omp.
Input must be a file of serialized NearNeighbours protos, such as might be generated by:

gfp_nearneighbours_single_file_tbb  -h 8 -S /tmp/rand50k.nn.tfdata -T 0.45 -v rand10k.gfp

then use the resulting .tfdata file here.

 -n <nsel>      number of items to select - by default all items are selected.
 -T <dist>      discard neighbours further away than <dist>
 -q <n>         squeeze out selected items every <n> items selected.
 -3             three column output 'smiles id distance'.
 -W ...         initialise weighting options, enter '-W help' for info.
 -e             input consists of nnbr::NearNeighboursIndices protos - possibly written by nn_id_to_ndx.
 -h <nthreads>  number of OMP threads to use.
 -S <fname>     smiles file that generated the nearneighbours - saves a scan through the input file.
 -D <fname>     write file of distance vs number selected to <fname>.
 -v             verbose output.
  )";
  // clang-format on

  exit(rc);
}

// Data associated with the run.
// There is not a well defined separation between what should be in this
// struct and what should be in the Spread class.
struct Data {
  public:
    // Programme works in two phases.
    // First the data is read and the name and smiles of each item is found and
    // placed in these arrays.

    resizable_array_p<IWString> smiles;
    resizable_array_p<IWString> id;

    // That also allows the `id_to_ndx` data structure to be built;
    IW_STL_Hash_Map_uint id_to_ndx;

    // Whether or not each candidate has been selected.
    int* selected;

    // If we squeeze the pool, we need a cross reference from old numbers to
    // new numbers.
    uint32_t* xref;

    // When we read the data, we can impose a maximum distance.
    float max_distance;

  public:
    Data();
    ~Data();

    // This is really more complexity that should be in a struct...
    int Initialise(Command_Line& cl, char flag);
};

Data::Data() {
  selected = nullptr;
  xref = nullptr;
  max_distance = 1.1f;  // something greater than 1
}

Data::~Data() {
  delete [] selected;
  delete [] xref;
}

int
Data::Initialise(Command_Line& cl, char flag) {
  const int verbose = cl.option_present(flag);

  IWString s;
  if (cl.option_present('T')) {
    if (! cl.value(flag, max_distance) || max_distance <= 0.0f || max_distance > 1.0f) {
      cerr << "Invalid maximum distance specification (-T)\n";
      return 1;
    }

    if (verbose) {
      cerr << "Will discard neighbours with distances > " << max_distance << '\n';
    }
  }

  return 1;
}

class SpreadItem {
  private:
    // Each item keeps track of how close it is to a selected item.
    float _shortest_distance_to_selected;

    // We also need to keep track of the index value for the neighbour
    // with that distance.
    // It is important to note that this is an index into the starting
    // smiles and id arrays. During squeezing this will not be changed.
    uint32_t _index_of_shortest_distance;

    // The number of neighbours we have.
    uint32_t _nbrs;

    // The id and distance of each neighbour.
    // Cound have used an id+distance struct, but no real advantage.
    uint32_t* _nbr;
    float* _dist;

    float _weight;

    // A unique id for this item. Actually it is the position of this
    // item in the global smiles and id arrays.
    uint32_t _uid;

  public:
    SpreadItem();
    ~SpreadItem();

    int Build(const nnbr::NearNeighbours& proto,
              uint32_t ndx,
              const Data& data);
    int Build(const nnbr::NearNeighboursIndices& proto,
              uint32_t ndx,
              const Data& data);

    int number_neighbours() const {
      return _nbrs;
    }
    uint32_t* nbrs() const {
      return _nbr;
    }

    // All the stored distances are updated as well.
    void set_weight(float s);

    void set_uid(uint32_t s) {
      _uid = s;
    }
    uint32_t uid() const {
      return _uid;
    }

    uint32_t index_of_shortest_distance() const {
      return _index_of_shortest_distance;
    }
    float shortest_distance_to_selected() const {
      return _shortest_distance_to_selected;
    }

    int DebugPrint(std::ostream& output) const;

    float unweighted_distance(uint32_t nbr) const;

    void Squeeze(const Data& data);

    // If item `ndx` has been selected, we may need to update our
    // _shortest_distance_to_selected value and
    // _index_of_shortest_distance. That will be set to `nbr`
    // if it is updated.
    void ItemHasBeenSelected(uint32_t ndx, uint32_t nbr);

    // Among our already selected neighbours, what is the shortest distance.
    // If successful, `ndx_of_closest` will be the index of the closest,
    // previously selected neighbour, and `closest_distance` will be the
    // corresponding distance.
    bool ClosestToAlreadySelected(uint32_t& ndx_of_closest,
                                  float& closest_distance) const;
    // Same except that it does not fill in ndx_of_closest.
    bool ClosestToAlreadySelected(float& closest_distance) const;
};

// A special value that will show up when an item is selected
// and none of its neighbours have been selected.
constexpr float kNoNeighboursSelected = 0.99f;

SpreadItem::SpreadItem() {
  _index_of_shortest_distance = kNoNeighboursSelected;
  _shortest_distance_to_selected = 2.0f;
  _nbrs = 0;
  _nbr = nullptr;
  _dist = nullptr;

  _weight = 1.0f;
  _uid = 0;
}

SpreadItem::~SpreadItem() {
  delete [] _nbr;
  delete [] _dist;
}

int
SpreadItem::DebugPrint(std::ostream& output) const {
  output << "SpreadItem with " << _nbrs << " neighbours\n";
  for (uint32_t i = 0; i < _nbrs; ++i) {
    if (i > 0) {
      output << ' ';
    }
    output << _nbr[i] << ' ' << _dist[i];
  }

  output << '\n';
  if (_nbrs > 0) {
    output << "_index_of_shortest_distance " << _index_of_shortest_distance << " _shortest_distance_to_selected " << _shortest_distance_to_selected << '\n';
  }

  return output.good();
}

// Return the value for the key `id` in `id_to_ndx`.
std::optional<uint32_t>
GetNbrId(const std::string& id, const IW_STL_Hash_Map_uint& id_to_ndx) {
  IWString s(id);

  s.truncate_at_first(' ');

  const auto f = id_to_ndx.find(s);

  if (f == id_to_ndx.end()) {
    cerr << "GetNbrId:no number for '" << id << "'\n";
    return std::nullopt;
  }

  return f->second;
}

// Build from `proto` in a situation where our index will be `my_ndx`.
// If we detect self neighbours in the input, drop them.
int
SpreadItem::Build(const nnbr::NearNeighbours& proto,
                  uint32_t my_ndx,
                  const Data& data) {
  _nbrs = proto.nbr_size();
  _nbr = new uint32_t[_nbrs];
  _dist = new float[_nbrs];

  int ndx = 0;  // Index into the arrays.

  for (const nnbr::Nbr& nbr : proto.nbr()) {
    std::optional<uint32_t> maybe_nbr = GetNbrId(nbr.id(), data.id_to_ndx);
    if (!maybe_nbr) {
      cerr << "Leader_Item::build:invalid neighbour specification '" << nbr.id() << "'\n";
      return 0;
    }
    if (*maybe_nbr ==  my_ndx) {
      --_nbrs;
      continue;
    }

    _nbr[ndx] = *maybe_nbr;

    float d = nbr.dist();

    assert(d >= 0.0f && d <= 1.0f);

    if (d > data.max_distance) {
      continue;
    }

    _dist[ndx] = d;

    ++ndx;
  }
  _nbrs = ndx;

#ifdef DEBUG_BUILD
  cerr << "Item " << _ndx << " has " << _nbrs << " neighbours\n";
  for (int i = 0; i < _nbrs; ++i) {
    cerr << ' ' << _nbr[i] << '\n';
  }
#endif

  return 1;
}

// Build from `proto` in a situation where our index will be `my_ndx`.
// If we detect self neighbours in the input, drop them.
int
SpreadItem::Build(const nnbr::NearNeighboursIndices& proto,
                  uint32_t my_ndx,
                  const Data& data) {
  _nbrs = proto.nbr_size();
  _nbr = new uint32_t[_nbrs];
  _dist = new float[_nbrs];

  int ndx = 0;  // Index into the arrays.

  for (const nnbr::NbrNdx& nbr : proto.nbr()) {
    float d = nbr.dist();

    assert(d >= 0.0f && d <= 1.0f);

    if (d > data.max_distance) {
      continue;
    }

    uint32_t n = nbr.id();
    if (n == my_ndx) [[ unlikely ]] {
      continue;
    }

    if (n >= data.smiles.size()) {
      cerr << "SpreadItem::Buiid:nbr number out of range\n";
      cerr << data.smiles.size() << " smiles, nbr " << n << '\n';
      return 0;
    }

    _nbr[ndx] = n;
    _dist[ndx] = d;

    ++ndx;
  }

  _nbrs = ndx;

#ifdef DEBUG_BUILD
  cerr << "Item " << _ndx << " has " << _nbrs << " neighbours\n";
  for (int i = 0; i < _nbrs; ++i) {
    cerr << ' ' << _nbr[i] << '\n';
  }
#endif

  return 1;
}

void
SpreadItem::set_weight(float s) {
  _weight = s;
  for (uint32_t i = 0; i < _nbrs; ++i) {
    _dist[i] *= _weight;
  }
}

float
SpreadItem::unweighted_distance(uint32_t nbr) const {
  for (uint32_t i = 0; i < _nbrs; ++i) {
    if (_nbr[i] != nbr) {
      continue;
    }

    return _dist[i] / _weight;
  }

  // SHould not happen.
  return -0.0f;
}

// The overall system is looking for the SpreadItem that is furthest
// away from an already selected item.
// So far, the furthest item is `closest_distance`. If we are larger
// then that, then update `closest_distance` and `ndx_of_closest`.
#ifdef NO_LONGER_USED_JJ
bool
SpreadItem::ClosestToAlreadySelected(uint32_t& ndx_of_closest,
                        float& closest_distance) const {

  // cerr << "ClosestToAlreadySelected, _shortest_distance_to_selected " << _shortest_distance_to_selected << " cmp " << closest_distance << '\n';
  if (closest_distance > _shortest_distance_to_selected) {
    return false;
  }

  // We are further away, update the arguments and return true.
  closest_distance = _shortest_distance_to_selected;
  ndx_of_closest = _index_of_shortest_distance;

  return true;
}
#endif

bool
SpreadItem::ClosestToAlreadySelected(float& closest_distance) const {

  // cerr << "ClosestToAlreadySelected, _shortest_distance_to_selected " << _shortest_distance_to_selected << " cmp " << closest_distance << '\n';
  if (_shortest_distance_to_selected < closest_distance) {
    return false;
  }

  // We are further away, update the arguments and return true.
  closest_distance = _shortest_distance_to_selected;

  return true;
}

// Item `sel` has just been selected. 
// Scan our list of neighbours and find `sel`. Update
// _shortest_distance_to_selected if needed.
// `nbr` is the initial index of `sel`, so we can find its
// smiles and id.
void
SpreadItem::ItemHasBeenSelected(uint32_t sel, uint32_t nbr) {
  for (uint32_t i = 0; i < _nbrs; ++i) {
    if (_nbr[i] != sel) {
      continue;
    }

    if (_dist[i] < _shortest_distance_to_selected) {
      _shortest_distance_to_selected = _dist[i];
      _index_of_shortest_distance = nbr;
    }
    return;
  }
  // SHould not come here.
}

void
SpreadItem::Squeeze(const Data& data) {
  uint32_t ndx = 0;
  for (uint32_t i = 0; i < _nbrs; ++i) {
    uint32_t j = _nbr[i];
    if (data.selected[j]) {
      continue;
    }

    _nbr[ndx] = data.xref[j];
    _dist[ndx] = _dist[i];
    ++ndx;
  }

  _nbrs = ndx;
}

uint32_t kUnsetNeighbour = std::numeric_limits<uint32_t>::max();


class Spread {
  private:
    // The number of items to select.
    uint32_t _items_to_select;

    int _weight_column;

    resizable_array_p<SpreadItem> _pool;

    uint32_t _squeeze;
    uint32_t _next_squeeze;

    // As the data is read, anything with 0 neighbours is a singleton
    // and will be selected immediately, and not added to the pool.
    // Keep track of how many of these there are.
    uint32_t _singleton_count;

    bool _three_column_output;
    IWString _output_separator;

    spread_weights::ScalingFactor _weights;

    // Will be set if we are reading nnbr::NearNeighboursIndices protos.
    int _nbr_data_is_indices;

    // Number of OMP threads to use.
    int _nthreads;

    int _verbose;

    Report_Progress _report_progress;

    // We can make generating a plot of distances easier.
    IWString_and_File_Descriptor _selected_distances_stream;

  // Private functions.
    template <typename T> int AddToPool(const T& proto,
          const Data& data,
          IWString_and_File_Descriptor& output);
    template <typename T>bool EstablishCrossReferences(const T& proto, Data& data);
    template <typename T> uint32_t EstablishCrossReferences(TFDataReader& input, Data& data);
    bool EstablishCrossReferences(const IWString& smiles,
                                 IWString& id,
                                 Data& data);
    uint32_t ReadSmiles(iwstring_data_source& input, Data& data);
    bool ReadSmilesRecord(const const_IWSubstring& buffer, Data& data);
    uint32_t ReadNbrData(TFDataReader& input,
            const Data& data,
            IWString_and_File_Descriptor& output);
    uint32_t ReadNbrDataIndics(TFDataReader& input,
                          const Data& data,
                          IWString_and_File_Descriptor& output);
    template <typename T> int HandleSingleton(const T& proto,
                        IWString_and_File_Descriptor& output);
    bool MostDistant(Data& data, uint32_t& ndx_of_furthest,
                    uint32_t& nbr_of_furthest,
                    float& longest_distance) const;
    bool MostDistantOmp(Data& data, uint32_t& ndx_of_furthest,
                    uint32_t& nbr_of_furthest,
                    float& longest_distance) const;
    int ItemHasBeenSelected(Data& data, uint32_t sel,
                uint32_t nbr,
                float dist,
                IWString_and_File_Descriptor& output);
    void WriteSmilesId(const Data& data, uint32_t ndx, IWString_and_File_Descriptor& output) const;
    void ThreeColumOutput(const Data& data, uint32_t ndx, uint32_t nbr, float dist, 
                        IWString_and_File_Descriptor& output) const;
    int FirstItemHasBeenSelected(Data& data, uint32_t sel,
                IWString_and_File_Descriptor& output);

    int Squeeze(Data& data);

  public:
    Spread();

    int Initialise(Command_Line& cl);

    uint32_t EstablishCrossReferences(const char* fname, Data& data);
    uint32_t ReadSmiles(const IWString& fname, Data& data);

    int InitialiseWeights(Data& data);

    uint32_t size() const {
      return _pool.size();
    }

    uint32_t squeeze() const {
      return _squeeze;
    }

    void ReservePool(uint32_t s) {
      _pool.reserve(s);
    }

    int singleton_count() const {
      return _singleton_count;
    }

    // If we are squeezing or _nbr_data_is_indices
    bool xref_needed() const {
      return _squeeze > 0 || _nbr_data_is_indices;
    }

    // If we are reading NearNeighboursIndices protos, we have loaded _pool
    // with nullptr entries. Remove them and adjust everyone's numbering.
    int SqueezeSingletons(Data& data);

    uint32_t ReadNbrData(const char* fname,
            const Data& data,
            IWString_and_File_Descriptor& output);

    template <typename T> uint32_t ReadNbrDataTemplate(TFDataReader& input,
            const Data& data,
            IWString_and_File_Descriptor& output);

    Accumulator_Int<uint64_t> Nbrs() const;

    uint32_t SpreadSelection(Data& data, IWString_and_File_Descriptor& output);
};

Spread::Spread() {
  _items_to_select = std::numeric_limits<uint32_t>::max();
  _nthreads = 0;
  _squeeze = 0;
  _next_squeeze = std::numeric_limits<uint32_t>::max();
  _singleton_count = 0;
  _three_column_output = false;
  _output_separator = ' ';
  _nbr_data_is_indices = 0;
  _verbose = 0;
}

int
Spread::Initialise(Command_Line& cl) {

  _verbose = cl.option_present('v');

  if (cl.option_present('e')) {
    _nbr_data_is_indices = 1;
    if (_verbose) {
      cerr << "Input files assumed to be TFDataRecord serialized nnbr::NearNeighboursIndices\n";
    }
  }

  if (cl.option_present('n')) {
    if (! cl.value('n', _items_to_select)) {
      cerr << "Invalid items to select (-n)\n";
      return 0;
    }

    if (_verbose) {
      cerr << "Will select " << _items_to_select << " items\n";
    }
  }

  if (cl.option_present('s')) {
    uint32_t s;
    if (! cl.value('s', s)) {
      cerr << "Invalid pool size estimate '" << s << "'\n";
      return 0;
    }
    if (_verbose) {
      cerr << "Space reserved for " << s << " items\n";
    }

    _pool.reserve(s);
  }

  if (cl.option_present('3')) {
    _three_column_output = true;
    if (_verbose) {
      cerr << "Will generate three column output: smiles id distance\n";
    }
  }

  if (cl.option_present('q')) {
    if (! cl.value('q', _squeeze) || _squeeze == 0) {
      cerr << "The squeeze optio (-q) must be a whole +ve number\n";
      return 0;
    }
    if (_verbose) {
      cerr << "Will squeeze out selected items every " << _squeeze << " items selected\n";
    }
    _next_squeeze = _squeeze;
  }

  if (cl.option_present('W')) {
    if (! _weights.Initialise(cl, 'W', _verbose)) {
      return 0;
    }
  }

  if (cl.option_present('h')) {
    if (! cl.value('h', _nthreads) || _nthreads < 1) {
      cerr << "The number of OMP threads must be a whole +ve number\n";
      Usage(1);
    }
    omp_set_num_threads(_nthreads);
    if (_verbose) {
      cerr << "Will use " << _nthreads << " threads\n";
    }
  }

  if (cl.option_present('D')) {
    IWString fname = cl.string_value('D');
    if (! _selected_distances_stream.open(fname)) {
      cerr << "Spread::Initialise:cannot open stream for selected distances " << fname << "\n";
      return 0;
    }
    if (_verbose) {
      cerr << "Selection distance written to '" << fname << "'\n";
    }
    _selected_distances_stream << "Sel Dist\n";
  }

  if (cl.option_present('r')) {
    if (! _report_progress.initialise(cl, 'r', _verbose)) {
      cerr << "Spread::Initialise:cannot initialise progress reporting (-r)\n";
      return 0;
    }
  }

  return 1;
}

// Just fill the data.selected array and call Squeeze.
int
Spread::SqueezeSingletons(Data& data) {
  if (! _nbr_data_is_indices) {
    return 1;
  }

  const uint32_t n = _pool.size();

  for (uint32_t i = 0; i < n; ++i) {
    if (_pool[i] == nullptr) {
      data.selected[i] = 1;
    } else {
      data.selected[i] = 0;
    }
  }

  return Squeeze(data);
}

template <typename T>
int
Spread::HandleSingleton(const T& proto,
                        IWString_and_File_Descriptor& output) {
  ++_singleton_count;

  if (_three_column_output) {
    output << proto.smiles() << _output_separator << proto.name() << _output_separator << '\n';
  } else {
    output << smiles_tag << proto.smiles() << ">\n";
    output << identifier_tag << proto.name() << ">\n";
    output << distance_tag << "1>\n";
    output << "|\n";
  }

  output.write_if_buffer_holds_more_than(4096);

  return 1;
}

template <typename T>
int
Spread::AddToPool(const T& proto,
          const Data& data,
          IWString_and_File_Descriptor& output) {
  std::unique_ptr<SpreadItem> s = std::make_unique<SpreadItem>();

  // We need to pass on the index that `s` will have.
  uint32_t ndx = _pool.size();

  if (! s->Build(proto, ndx, data)) {
    cerr << "AddToPool:invalid proto data " << proto.ShortDebugString() << '\n';
    return 0;
  }

  if (s->number_neighbours() == 0) {
    if (_nbr_data_is_indices) {
      _pool << static_cast<SpreadItem*>(nullptr);
    }

    return HandleSingleton(proto, output);
  }

  s->set_uid(_pool.size());
  _pool << s.release();

  return 1;
}

template <typename T>
uint32_t
Spread::ReadNbrDataTemplate(TFDataReader& input,
            const Data& data,
            IWString_and_File_Descriptor& output) {
  while (1) {
    std::optional<T> maybe_proto = input.ReadProto<T>();
    if (! maybe_proto) {
      return _pool.size();
    }

    AddToPool(*maybe_proto, data, output);
  }

  return _pool.size();
}
                

uint32_t
Spread::ReadNbrData(TFDataReader& input,
            const Data& data,
            IWString_and_File_Descriptor& output) {
  return ReadNbrDataTemplate<nnbr::NearNeighbours>(input, data, output);
}

uint32_t
Spread::ReadNbrDataIndics(TFDataReader& input,
                          const Data& data,
                          IWString_and_File_Descriptor& output) {
  return ReadNbrDataTemplate<nnbr::NearNeighboursIndices>(input, data, output);
}

uint32_t
Spread::ReadNbrData(const char* fname,
            const Data& data,
            IWString_and_File_Descriptor& output) {

  TFDataReader input(fname);
  if (! input.good()) {
    cerr << "ReadNbrData:cannot open '" << fname << "'\n";
    return 0;
  }

  if (_nbr_data_is_indices) {
    return ReadNbrDataIndics(input, data, output);
  }

  return ReadNbrData(input, data, output);
}

template <typename T>
bool
Spread::EstablishCrossReferences(const T& proto, Data& data) {
  IWString smiles = proto.smiles();
  IWString id = proto.name();

  return EstablishCrossReferences(smiles, id, data);
}

bool
Spread::EstablishCrossReferences(const IWString& smiles,
                                 IWString& id,
                                 Data& data) {
  id.truncate_at_first(' ');

  if (auto iter = data.id_to_ndx.find(id); iter != data.id_to_ndx.end()) {
    cerr << "Spread::EstablishCrossReferences:duplicate identifier '" << id << "'\n";
    return false;
  }

  auto s = data.id.size();

  assert(s == data.smiles.size());

  data.id << new IWString(id);
  data.smiles << new IWString(smiles);
  
  data.id_to_ndx[id] = s;

  return true;
}

template <typename T>
uint32_t
Spread::EstablishCrossReferences(TFDataReader& input, Data& data) {
  uint32_t items_read = 0;

  while (1) {
    std::optional<T> maybe_proto = input.ReadProto<T>();
    if (! maybe_proto) {
      return items_read;
    }

    // If indexing is being done by names, we can skip singletons here.
    if (_nbr_data_is_indices) {
    } else if (maybe_proto->nbr_size() == 0) {
      continue;
    }

    if (! EstablishCrossReferences(*maybe_proto, data)) {
      return 0;
    }

    ++items_read;
  }

  return items_read;
}

uint32_t
Spread::EstablishCrossReferences(const char* fname, Data& data) {
  TFDataReader input(fname);
  if (! input.good()) {
    cerr << "Spread::EstablishCrossReferences:cannot open '" << fname << "'\n";
    return 0;
  }

  if (_nbr_data_is_indices) {
    return EstablishCrossReferences<nnbr::NearNeighboursIndices>(input, data);
  } else {
    return EstablishCrossReferences<nnbr::NearNeighbours>(input, data);
  }
}

uint32_t
Spread::ReadSmiles(const IWString& fname, Data& data) {
  iwstring_data_source input(fname);

  if (! input.good()) {
    cerr << "Spread::ReadSmiles:cannot open '" << fname << "'\n";
    return 0;
  }

  return ReadSmiles(input, data);
}

uint32_t
Spread::ReadSmiles(iwstring_data_source& input, Data& data) {
  const_IWSubstring buffer;
  while (input.next_record(buffer)) {
    if (! ReadSmilesRecord(buffer, data)) {
      cerr << "Spread::ReadSmiles:cannot parse '" << buffer << "'\n";
      return 0;
    }
  }

  return data.id_to_ndx.size();
}

bool
Spread::ReadSmilesRecord(const const_IWSubstring& buffer, Data& data) {
  IWString smiles, id;
  int i = 0;
  if (! buffer.nextword(smiles, i) || ! buffer.nextword(id, i)) {
    cerr << "Spread::ReadSmilesRecord:invalid input\n";
    return 0;
  }

  return EstablishCrossReferences(smiles, id, data);
}

// When profiling is run, this is the most prominent function
// consuming 30% of CPU
bool
Spread::MostDistant(Data& data, uint32_t& ndx_of_furthest,
                    uint32_t& nbr_of_furthest,
                    float& longest_distance) const {
  if (_nthreads > 0) {
    return MostDistantOmp(data, ndx_of_furthest, nbr_of_furthest, longest_distance);
  }

  const uint32_t n = _pool.size();

  longest_distance = -1.0f;

  for (uint32_t i = 0; i < n; ++i) {
    if (data.selected[i]) [[ unlikely ]] {
      continue;
    }

    if (_pool[i]->ClosestToAlreadySelected(longest_distance)) {
      ndx_of_furthest = i;
    }
  }

  if (longest_distance < 0.0f) [[ unlikely]] {
    return false;
  }

  nbr_of_furthest = _pool[ndx_of_furthest]->index_of_shortest_distance();

  return true;
}

bool
Spread::MostDistantOmp(Data& data, uint32_t& ndx_of_furthest,
                    uint32_t& nbr_of_furthest,
                    float& longest_distance) const {
  const uint32_t n = _pool.size();

  longest_distance = -1.0f;

  // cerr << "MostDistant scanning " << n << " items\n";
  // uint32_t count_nsel = 0;
#pragma omp parallel
  {
    float longest_distance_private = -1.0f;
    uint32_t ndx_of_furthest_private = 0;
#pragma omp for schedule(dynamic, 8192) nowait
    for (uint32_t i = 0; i < n; ++i) {
      if (data.selected[i]) [[ unlikely ]] {
        continue;
      }

      if (_pool[i]->ClosestToAlreadySelected(longest_distance_private)) {
        ndx_of_furthest_private = i;
      }
    }
#pragma omp critical
    {  // reduce across threads
      if (longest_distance_private > longest_distance) {
        longest_distance = longest_distance_private;
        ndx_of_furthest = ndx_of_furthest_private;
      }
    }  // pragma imp critical
  }  // pragma omp parallel

  if (longest_distance < 0.0f) [[ unlikely ]] {
    return false;
  }

  nbr_of_furthest = _pool[ndx_of_furthest]->index_of_shortest_distance();

  return true;
}

uint32_t
Spread::SpreadSelection(Data& data, IWString_and_File_Descriptor& output) {

  FirstItemHasBeenSelected(data, 0, output);

  uint32_t items_selected = 1;
  // cerr << "Begin spread\n";

  while (items_selected < _items_to_select) {
    // cerr << items_selected << " items selected, need " << _items_to_select << " pool contains " << _pool.size() << '\n';
    uint32_t most_distant;
    uint32_t prev_sel;
    float longest_distance;
    if (! MostDistant(data, most_distant, prev_sel, longest_distance)) {
      break;
    }
    // cerr << "most_distant " << most_distant << " nbr " << prev_sel << " dist " << longest_distance << '\n';

    ItemHasBeenSelected(data, most_distant, prev_sel, longest_distance, output);
    ++items_selected;

    // cerr << items_selected << " items selected, _next_squeeze " << _next_squeeze << '\n';
    if (items_selected > _next_squeeze) {
      Squeeze(data);
    }
    if (_report_progress()) {
      cerr << "Selected " << items_selected << " distance " << longest_distance <<
              " pool contains " << _pool.size() << " items\n";
    }
  }

  output.flush();

  return items_selected;
}

// Write in TDT form the smiles and identifier for item `ndx`.
void
Spread::WriteSmilesId(const Data& data, uint32_t ndx, 
                      IWString_and_File_Descriptor& output) const {
  output << smiles_tag << *data.smiles[ndx] << ">\n";
  output << identifier_tag << *data.id[ndx] << ">\n";
}

void
Spread::ThreeColumOutput(const Data& data, uint32_t ndx,
                        uint32_t nbr, float dist, 
                        IWString_and_File_Descriptor& output) const {
  output << *data.smiles[ndx] << _output_separator <<
            *data.id[ndx];
  // No, this is not correct...
  if (dist >= 0.0f) {
    output << _output_separator << dist;
    if (_weights.active() && nbr != kUnsetNeighbour) {
      output << _output_separator << _pool[ndx]->unweighted_distance(nbr);
    }
  }
  output << '\n';
}

int
Spread::FirstItemHasBeenSelected(Data& data, uint32_t sel,
                IWString_and_File_Descriptor& output) {
  assert(data.selected[sel] == 0);

  uint32_t initial_index = _pool[sel]->uid();

  if (_three_column_output) {
    ThreeColumOutput(data, initial_index, kUnsetNeighbour, -1.0f, output);
  } else {
    WriteSmilesId(data, initial_index, output);
    output << "|\n";
  }

  data.selected[sel] = 1;

  // Notify all pool members that this first item has been selected.
  for (SpreadItem* s : _pool) {
    s->ItemHasBeenSelected(sel, 0);  // should not be 0, fix...
  }

  return 1;
}

int
Spread::ItemHasBeenSelected(Data& data, uint32_t sel,
                uint32_t nbr,
                float dist,
                IWString_and_File_Descriptor& output) {
  assert(data.selected[sel] == 0);

  const uint32_t initial_index = _pool[sel]->uid();

  if (_three_column_output) {
    ThreeColumOutput(data, initial_index, nbr, dist, output);
  } else {
    WriteSmilesId(data, initial_index, output);
    if (dist != kNoNeighboursSelected) {
      WriteSmilesId(data, nbr, output);
      output << distance_tag << dist << ">\n";
    }
    output << "|\n";
  }

  // Only write a point when it is significantly different from what was
  // previously written.
  if (_selected_distances_stream.is_open()) {
    static uint32_t number_selected;
    static float previous_distance = 2.0f;
    if ((previous_distance - dist) >= 0.001) {
      _selected_distances_stream << number_selected << ' ' << dist << '\n';
      previous_distance = dist;
      _selected_distances_stream.write_if_buffer_holds_more_than(4096);
    }

    ++number_selected;
  }

  output.write_if_buffer_holds_more_than(4192);

  data.selected[sel] = 1;

  // Tell the unselected neighbours of `sel` that `sel` has been selected.

  const uint32_t sel_index = _pool[sel]->uid();
  const uint32_t* nbrs = _pool[sel]->nbrs();
#pragma omp parallel for schedule(dynamic, 16)
  for (int i = 0; i < _pool[sel]->number_neighbours(); ++i) {
    uint32_t nbr = nbrs[i];
    if (data.selected[nbr]) {
      continue;
    }

    _pool[nbr]->ItemHasBeenSelected(sel, sel_index);
  }

  return 1;
}

int
Spread::Squeeze(Data& data) {
  assert(data.xref != nullptr);

  const uint32_t n = _pool.size();
  uint32_t ndx = 0;
  // cerr << "Spread::Squeeze: pool contains " << n << " items\n";
  for (uint32_t i = 0; i < n; ++i) {
    if (data.selected[i]) {
      continue;
    }

    data.xref[i] = ndx;
    // cerr << " item " << i << " xref " << data.xref[i] << '\n';
    ++ndx;
  }
  // cerr << "Xref updated\n";

  // Remove selected items from _pool.
  // Note that we cannot use a uint32_t in the for loop if descending...
  for (uint32_t i = 0; i < n; ++i) {
    uint32_t j = n - i - 1;
    if (data.selected[j]) {
      _pool.remove_item(j);
    }
  }

  for (SpreadItem* s : _pool) {
    s->Squeeze(data);
  }

  // All items are unselected now.
  // cerr << "Spread::Squeeze ndx " << ndx << '\n';
  std::fill_n(data.selected, ndx, 0);

  //cerr << "After squeeze pool contains " << _pool.size() << " items\n";
  _next_squeeze += _squeeze;

  return 1;
}

Accumulator_Int<uint64_t> 
Spread::Nbrs() const {
  Accumulator_Int<uint64_t> result;

  for (const SpreadItem* s : _pool) {
    if (s == nullptr) {
      continue;
    }

    result.extra(s->number_neighbours());
  }

  return result;
}

int
Spread::InitialiseWeights(Data& data) {
  if (! _weights.active()) {
    return 1;
  }

  const uint32_t n = _pool.size();

  for (uint32_t i = 0; i < n; ++i) {
    std::optional<float> w = _weights.Weight(*data.id[i]);
    if (! w) {
      cerr << "Spread::InitialiseWeights:no weight for '" << *data.id[i] << "'\n";
      return 0;
    }

    _pool[i]->set_weight(*w);
  }

  return 1;
}

int
Main(int argc, char** argv) {
  Command_Line cl(argc, argv, "vs:n:3q:T:W:h:S:eD:r:");

  if (cl.unrecognised_options_encountered()) {
    cerr << "Unrecognised options encountered\n";
    Usage(1);
  }

  const int verbose = cl.option_count('v');

  Spread spread;

  if (! spread.Initialise(cl)) {
    cerr << "Cannot initialise spread parameters\n";
  }

  if (cl.empty()) {
    cerr << "Must specify TFDataRecord input file consisting of serialised NearNeighbours protos\n";
    Usage(1);
  }

  Data data;

  if (! data.Initialise(cl, 'D')) {
    cerr << "Cannot initialise Data struct\n";
    return 1;
  }

  const auto tzero = std::chrono::system_clock::now();

  uint32_t items_in_input = 0;

  if (cl.option_present('S')) {
    IWString fname = cl.string_value('S');
    items_in_input = spread.ReadSmiles(fname, data);
    if (items_in_input == 0) {
      cerr << "Cannot read smiles '" << fname << "'\n";
      return 1;
    }
  } else {
    for (const char* fname: cl) {
      uint32_t tmp = spread.EstablishCrossReferences(fname, data);
      if (tmp == 0) {
        cerr << "Cannot establish cross reference information in '" << fname << "'\n";
        return 1;
      }
      items_in_input += tmp;
    }
  }

  if (verbose) {
    cerr << "Read " << items_in_input << " items + nearest neighbour data\n";
    cerr << data.id_to_ndx.size() << " items in hash\n";
  }

#ifdef ECHO_ID_TO_NDX
  for (const auto& [key, value] :data.id_to_ndx) {
    cerr << "key " << key << " value " << value << '\n';
  }
#endif

  spread.ReservePool(items_in_input);
  data.selected = new_int(items_in_input);

  if (spread.xref_needed()) {
    data.xref = new uint32_t[items_in_input];
  }

  // Declare now because singletons are discarded as the data is read.
  IWString_and_File_Descriptor output(1);

  for (const char* fname: cl) {
    if (verbose) {
      cerr << "Reading NNDATA from '" << fname << "'\n";
    }
    if (! spread.ReadNbrData(fname, data, output)) {
      cerr << "Cannot read nearest neighbour data from '" << fname << "'\n";
      return 1;
    }
  }

  if (verbose) {
    cerr << "Encountered " << spread.singleton_count() << " singletons\n";
    cerr << "Start with " << spread.size() << " candidates\n";
    const Accumulator_Int<uint64_t> acc_nbrs = spread.Nbrs();
    cerr << "Nbrs btw " << acc_nbrs.minval() << " and " << acc_nbrs.maxval() << 
            " ave " << static_cast<float>(acc_nbrs.average()) << '\n';
    auto now = std::chrono::system_clock::now();
    auto elapsed_seconds = std::chrono::duration_cast<std::chrono::seconds>(now - tzero);
    cerr << "Reading data took " << elapsed_seconds << " seconds\n";
  }

  if (cl.option_present('W')) {
    if (! spread.InitialiseWeights(data)) {
      cerr << "Cannot initialise weights\n";
    }
  }

  spread.SqueezeSingletons(data);

  if (verbose) {
    cerr << "After squeezing singletons " << spread.size() << '\n';
  }

  spread.SpreadSelection(data, output);

  output.flush();

  return 0;
}

}  // namespace nn_spread

int
main(int argc, char** argv) {
  int rc = nn_spread::Main(argc, argv);

  return rc;
}
